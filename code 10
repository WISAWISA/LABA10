//Скопировать текстовый файл, отсортировав строки по числу слов в строке.
#include <stdio.h>
#include <string.h>
#include <malloc.h>
#include <iostream>
//Каждое слово отделено проелом. В концк каждого слова - пробел. В конце файл обязательно \n;
void main(void) {
FILE *fpin; // входной файл
FILE *fpout; //выходной файл
char * buffer = NULL; // динамический массив для считывания очередной строки;
char **lines = NULL; // указатель на динамический массив;
int *S = NULL; // динамический массив, который хранит кол-во слов в каждой соответствующей строке
динамического массива lines
char *buf = NULL; // указатель для обменя/сортировки строк массива lines по данным о кол-ве слов,
хранящихся в динамическом массиве S;
char time; // переменная для очередного считывания символа из файла
int i = 0; //счетчик для остлеживания, сколько символов уже прочли
int lsize = 0; // длина строчки, которую надо будет считать. Определяет размер динамических массивов
buffer и lines[i]
int s = 0; // счетчик количества слов в строке
int n = 0; // счетчик количества строк, чтобы выделять вновь и вновь нужное количество памяти, когда
находится новая строчка
fpin = fopen("test.txt", "r");
while (!feof(fpin))// цикл до конца входного файла
{
time = fgetc(fpin); // считываем очередной элемент текста
lsize++; // счетчик длины предложения
i++;
if (time == '_') s++; //счетчик слов в строке
if (time == '\n') //закончилась строка, пора ее записывать
{
n++;//номер строки - количество строк
S = (int*)realloc(S, n* sizeof(int)); //перезаказываем массив, содержащий данные о
количестве слов в каждой строке
S[n-1] = s; //записываем количество слов, которое было в этой строке
buffer = (char*)realloc(buffer, (lsize) * sizeof(char)); //выделение нужного количества
памяти в массиве BUFFER
fseek(fpin, i - lsize, SEEK_SET); //перемещение на АКТУАЛЬНОЕ СЧИТЫВАНИЕ - КОЛИЧЕСТВО БУКВ
= НАЧАЛО НОВОГО ПРЕДЛОЖЕНИЯ
fread(buffer, 1, lsize, fpin); //считываем массив BUFFER (то, что было до Ентера)
buffer[lsize-1] = '\0';
// перезаказать динамический массив указателей c выделением памяти
lines = (char**)realloc(lines, n * sizeof(char*));
// заказать в памяти место для новой строки
lines[n-1] = (char*)malloc(sizeof(char) *(lsize));
//копируем строчку.
strcpy(lines[n-1], buffer);
i++;
s = 0; //обнуляем количество слов
lsize = 0; // обнуляем длину строки
}
}
fclose(fpin);
//сортировка методом пузырька
for (int i = n-1; i>=0; i--){
for (int j = 0; j <i; j++) {
if (S[j] > S[j + 1]) {
int buf0 = S[j];
5
S[j] = S[j + 1];
S[j + 1] = buf0;
buf = lines[j];
lines[j] = lines[j + 1];
lines[j + 1] = buf;
}
}
}
fpout = fopen("result.txt", "w");
//вывод на экран и правильное обнуление всех динамических массивов
for (int i = 0; i<n; i++)
{
puts(lines[i]); //вывод на экран
fprintf(fpout,"%s\n", lines[i]); //вывод в файл
free(lines[i]); //освобождение памяти
lines[i] = NULL;
printf("%d\n", S[i]); //вывод длины, которую мы считали, для удобства. В файле она отсутствует.
}
fclose(fpout);
free(S);
//освобождение памяти
S = NULL;
free(lines);
lines = NULL;
free(buffer);
buffer = NULL;
}
